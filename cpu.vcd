$date
	Wed Nov 16 21:27:18 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module alucontrol $end
$var wire 2 ! ALUop [1:0] $end
$var wire 6 " instruction [5:0] $end
$var reg 3 # ALUcontrol [2:0] $end
$upscope $end
$scope module cputest $end
$var reg 1 $ clk $end
$scope module test $end
$var wire 32 % ALU_in [31:0] $end
$var wire 3 & ALUop [2:0] $end
$var wire 32 ' ALUresult [31:0] $end
$var wire 1 ( ALUsrc $end
$var wire 1 ) ALUzero $end
$var wire 1 * Branch $end
$var wire 2 + Jump [1:0] $end
$var wire 1 , MemRead $end
$var wire 1 - MemWrite $end
$var wire 2 . MemtoReg [1:0] $end
$var wire 2 / RegDst [1:0] $end
$var wire 1 0 RegWrite $end
$var wire 32 1 SEinst [31:0] $end
$var wire 32 2 addALUres [31:0] $end
$var wire 32 3 branch_out [31:0] $end
$var wire 1 4 clk $end
$var wire 32 5 datamem_readData [31:0] $end
$var wire 32 6 inst [31:0] $end
$var wire 32 7 pc4_out [31:0] $end
$var wire 32 8 pc_in [31:0] $end
$var wire 32 9 pc_out [31:0] $end
$var wire 32 : reg_readData1 [31:0] $end
$var wire 32 ; reg_readData2 [31:0] $end
$var wire 32 < writeData [31:0] $end
$var wire 5 = writeRegister [4:0] $end
$scope module cpuPC $end
$var wire 1 4 clk $end
$var wire 32 > pc_in [31:0] $end
$var reg 32 ? pc_out [31:0] $end
$upscope $end
$scope module cpuIM $end
$var wire 32 @ instruction [31:0] $end
$var wire 32 A read_address [31:0] $end
$upscope $end
$scope module cpuControl $end
$var wire 1 B clk $end
$var wire 6 C instruction [5:0] $end
$var reg 3 D ALUOp [2:0] $end
$var reg 1 E ALUSrc $end
$var reg 1 F Branch $end
$var reg 2 G Jump [1:0] $end
$var reg 1 H MemRead $end
$var reg 1 I MemWrite $end
$var reg 2 J MemtoReg [1:0] $end
$var reg 2 K RegDst [1:0] $end
$var reg 1 L RegWrite $end
$upscope $end
$scope module mux5_inst_reg $end
$var wire 5 M in0 [4:0] $end
$var wire 5 N in1 [4:0] $end
$var wire 5 O in2 [4:0] $end
$var wire 2 P sel [1:0] $end
$var reg 5 Q out [4:0] $end
$scope begin MUX $end
$upscope $end
$upscope $end
$scope module cpuRegister $end
$var wire 1 4 clk $end
$var wire 32 R ra [31:0] $end
$var wire 5 S ra_addr [4:0] $end
$var wire 32 T rb [31:0] $end
$var wire 5 U rb_addr [4:0] $end
$var wire 32 V wd [31:0] $end
$var wire 5 W wd_addr [4:0] $end
$var wire 1 0 wrEn $end
$upscope $end
$scope module cpuSE $end
$var wire 16 X seIn [15:0] $end
$var wire 32 Y seOut [31:0] $end
$scope begin gen1[16] $end
$upscope $end
$scope begin gen1[17] $end
$upscope $end
$scope begin gen1[18] $end
$upscope $end
$scope begin gen1[19] $end
$upscope $end
$scope begin gen1[20] $end
$upscope $end
$scope begin gen1[21] $end
$upscope $end
$scope begin gen1[22] $end
$upscope $end
$scope begin gen1[23] $end
$upscope $end
$scope begin gen1[24] $end
$upscope $end
$scope begin gen1[25] $end
$upscope $end
$scope begin gen1[26] $end
$upscope $end
$scope begin gen1[27] $end
$upscope $end
$scope begin gen1[28] $end
$upscope $end
$scope begin gen1[29] $end
$upscope $end
$scope begin gen1[30] $end
$upscope $end
$scope begin gen1[31] $end
$upscope $end
$upscope $end
$scope module mux_reg_alu $end
$var wire 32 Z in0 [31:0] $end
$var wire 32 [ in1 [31:0] $end
$var wire 32 \ out [31:0] $end
$var wire 1 ( sel $end
$upscope $end
$scope module cpuALU $end
$var wire 32 ] a [31:0] $end
$var wire 32 ^ aluRes [31:0] $end
$var wire 3 _ alucontrol [2:0] $end
$var wire 32 ` b [31:0] $end
$var wire 1 ) zero $end
$var reg 32 a aluRes_reg [31:0] $end
$upscope $end
$scope module cpu_dm $end
$var wire 1 , MemRead $end
$var wire 1 - MemWrite $end
$var wire 32 b address [31:0] $end
$var wire 1 4 clk $end
$var wire 32 c readData [31:0] $end
$var wire 32 d writeData [31:0] $end
$var reg 32 e readData_reg [31:0] $end
$upscope $end
$scope module cpu_add_pc $end
$var wire 32 f in [31:0] $end
$var wire 32 g out [31:0] $end
$upscope $end
$scope module mux_datamem $end
$var wire 32 h in0 [31:0] $end
$var wire 32 i in1 [31:0] $end
$var wire 32 j in2 [31:0] $end
$var wire 2 k sel [1:0] $end
$var reg 32 l out [31:0] $end
$scope begin MUX $end
$upscope $end
$upscope $end
$scope module cpu_add_alu $end
$var wire 32 m in0 [31:0] $end
$var wire 32 n in1 [31:0] $end
$var wire 32 o out [31:0] $end
$upscope $end
$scope module mux_branch $end
$var wire 32 p in0 [31:0] $end
$var wire 32 q in1 [31:0] $end
$var wire 32 r out [31:0] $end
$var wire 1 s sel $end
$upscope $end
$scope module mux_jump $end
$var wire 32 t in0 [31:0] $end
$var wire 32 u in1 [31:0] $end
$var wire 32 v in2 [31:0] $end
$var wire 2 w sel [1:0] $end
$var reg 32 x out [31:0] $end
$scope begin MUX $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module test $end
$var wire 32 y aout [31:0] $end
$var wire 32 z bout [31:0] $end
$var reg 5 { a [4:0] $end
$var reg 5 | b [4:0] $end
$var reg 1 } clk $end
$var reg 32 ~ wrData [31:0] $end
$var reg 1 !" wrEn $end
$var reg 5 "" wrReg [4:0] $end
$scope module register $end
$var wire 1 #" clk $end
$var wire 32 $" ra [31:0] $end
$var wire 5 %" ra_addr [4:0] $end
$var wire 32 &" rb [31:0] $end
$var wire 5 '" rb_addr [4:0] $end
$var wire 32 (" wd [31:0] $end
$var wire 5 )" wd_addr [4:0] $end
$var wire 1 *" wrEn $end
$upscope $end
$upscope $end
$scope module alucontrol $end
$upscope $end
$scope module cputest $end
$scope module test $end
$scope module cpuPC $end
$upscope $end
$scope module cpuIM $end
$upscope $end
$scope module cpuControl $end
$upscope $end
$scope module mux5_inst_reg $end
$scope begin MUX $end
$upscope $end
$upscope $end
$scope module cpuRegister $end
$upscope $end
$scope module cpuSE $end
$scope begin gen1[16] $end
$upscope $end
$scope begin gen1[17] $end
$upscope $end
$scope begin gen1[18] $end
$upscope $end
$scope begin gen1[19] $end
$upscope $end
$scope begin gen1[20] $end
$upscope $end
$scope begin gen1[21] $end
$upscope $end
$scope begin gen1[22] $end
$upscope $end
$scope begin gen1[23] $end
$upscope $end
$scope begin gen1[24] $end
$upscope $end
$scope begin gen1[25] $end
$upscope $end
$scope begin gen1[26] $end
$upscope $end
$scope begin gen1[27] $end
$upscope $end
$scope begin gen1[28] $end
$upscope $end
$scope begin gen1[29] $end
$upscope $end
$scope begin gen1[30] $end
$upscope $end
$scope begin gen1[31] $end
$upscope $end
$upscope $end
$scope module mux_reg_alu $end
$upscope $end
$scope module cpuALU $end
$upscope $end
$scope module cpu_dm $end
$upscope $end
$scope module cpu_add_pc $end
$upscope $end
$scope module mux_datamem $end
$scope begin MUX $end
$upscope $end
$upscope $end
$scope module cpu_add_alu $end
$upscope $end
$scope module mux_branch $end
$upscope $end
$scope module mux_jump $end
$scope begin MUX $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module test $end
$scope module register $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1*"
b1000 )"
b110010 ("
bx '"
bx &"
b0 %"
b0 $"
0#"
b1000 ""
1!"
b110010 ~
0}
bx |
b0 {
bx z
b0 y
b1 x
b0 w
b0 v
b11101001111111111110000 u
b1 t
0s
b1 r
b1111111111110001 q
b1 p
b1111111111110001 o
b11111111111100 n
b1 m
b11111111111100 l
b0 k
b1 j
bx i
b11111111111100 h
b1 g
b0 f
bx e
bx d
bx c
b11111111111100 b
b11111111111100 a
b11111111111100 `
b100 _
b11111111111100 ^
b0 ]
b11111111111100 \
b11111111111100 [
bx Z
b11111111111100 Y
b11111111111100 X
b111 W
b11111111111100 V
b11101 U
bx T
b0 S
b0 R
b111 Q
b1 P
b11111 O
b111 N
b11101 M
1L
b1 K
b0 J
0I
0H
b0 G
0F
1E
b100 D
b1110 C
zB
b0 A
b111000000111010011111111111100 @
b0 ?
b1 >
b111 =
b11111111111100 <
bx ;
b0 :
b0 9
b1 8
b1 7
b111000000111010011111111111100 6
bx 5
14
b1 3
b1111111111110001 2
b11111111111100 1
10
b1 /
b0 .
0-
0,
b0 +
0*
0)
1(
b11111111111100 '
b100 &
b11111111111100 %
1$
b0 #
bz "
bz !
$end
#100000
0$
04
#200000
b100 l
b100 <
b100 V
b100 a
b100 '
b100 ^
b100 b
b100 h
b10 x
b10 8
b10 >
b100 %
b100 \
b100 `
b0 Q
b0 =
b0 W
b10 3
b10 r
b10 t
b1000000000000000010000 u
b100 1
b100 Y
b100 [
b100 n
b100 X
b1000 U
b0 N
b1000 M
b10010 2
b10010 o
b10010 q
b10 7
b10 g
b10 j
b10 m
b10 p
b1 ?
b111000000010000000000000000100 6
b111000000010000000000000000100 @
b1 9
b1 A
b1 f
1$
14
#300000
0$
04
