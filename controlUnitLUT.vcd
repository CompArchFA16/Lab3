$date
	Sun Nov 13 22:10:33 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module testlut $end
$var wire 1 ! ALU_input $end
$var wire 6 " ALUcommand [5:0] $end
$var wire 1 # Branch $end
$var wire 1 $ Jump $end
$var wire 2 % Jump_Target_Mux [1:0] $end
$var wire 2 & Reg_Data_Src_Mux [1:0] $end
$var wire 2 ' WrAddr_Reg_Mux [1:0] $end
$var wire 1 ( WrEn_DM $end
$var wire 1 ) WrEn_Reg $end
$var reg 6 * controlUnitCommand [5:0] $end
$var reg 6 + funct [5:0] $end
$scope module dut $end
$var wire 1 , ALU_input1 $end
$var wire 1 - ALU_input2 $end
$var wire 6 . ALUcommand1 [5:0] $end
$var wire 6 / ALUcommand2 [5:0] $end
$var wire 1 0 Branch1 $end
$var wire 1 1 Branch2 $end
$var wire 1 2 Jump1 $end
$var wire 1 3 Jump2 $end
$var wire 2 4 Jump_Target_Mux1 [1:0] $end
$var wire 2 5 Jump_Target_Mux2 [1:0] $end
$var wire 2 6 Reg_Data_Src_Mux1 [1:0] $end
$var wire 2 7 Reg_Data_Src_Mux2 [1:0] $end
$var wire 2 8 WrAddr_Reg_Mux1 [1:0] $end
$var wire 2 9 WrAddr_Reg_Mux2 [1:0] $end
$var wire 1 : WrEn_DM1 $end
$var wire 1 ; WrEn_DM2 $end
$var wire 1 < WrEn_Reg1 $end
$var wire 1 = WrEn_Reg2 $end
$var wire 6 > controlUnitCommand [5:0] $end
$var wire 6 ? funct [5:0] $end
$var reg 1 @ ALU_input $end
$var reg 6 A ALUcommand [5:0] $end
$var reg 1 B Branch $end
$var reg 1 C Jump $end
$var reg 2 D Jump_Target_Mux [1:0] $end
$var reg 2 E Reg_Data_Src_Mux [1:0] $end
$var reg 2 F WrAddr_Reg_Mux [1:0] $end
$var reg 1 G WrEn_DM $end
$var reg 1 H WrEn_Reg $end
$scope module lut_ctrl $end
$var wire 6 I controlUnitCommand [5:0] $end
$var wire 6 J funct [5:0] $end
$var reg 1 K ALU_input $end
$var reg 6 L ALUcommand [5:0] $end
$var reg 1 M Branch $end
$var reg 1 N Jump $end
$var reg 2 O Jump_Target_Mux [1:0] $end
$var reg 2 P Reg_Data_Src_Mux [1:0] $end
$var reg 2 Q WrAddr_Reg_Mux [1:0] $end
$var reg 1 R WrEn_DM $end
$var reg 1 S WrEn_Reg $end
$upscope $end
$scope module R_ctrl $end
$var wire 6 T funct [5:0] $end
$var reg 1 U ALU_input $end
$var reg 6 V ALUcommand [5:0] $end
$var reg 1 W Branch $end
$var reg 1 X Jump $end
$var reg 2 Y Jump_Target_Mux [1:0] $end
$var reg 2 Z Reg_Data_Src_Mux [1:0] $end
$var reg 2 [ WrAddr_Reg_Mux [1:0] $end
$var reg 1 \ WrEn_DM $end
$var reg 1 ] WrEn_Reg $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
x]
x\
bx [
bx Z
bx Y
xX
xW
bx V
xU
bx T
xS
xR
bx Q
bx P
bx O
xN
xM
bx L
xK
bx J
bx I
xH
xG
bx F
bx E
bx D
xC
xB
bx A
x@
bx ?
bx >
x=
x<
x;
x:
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
x3
x2
x1
x0
bx /
bx .
x-
x,
bx +
bx *
x)
x(
bx '
bx &
bx %
x$
x#
bx "
x!
$end
#2000
1B
1#
b10 D
b10 %
0C
0$
b0 E
b0 &
b1 A
b1 "
1@
1!
b0 F
b0 '
0G
0(
0H
0)
1M
10
b10 O
b10 4
0N
02
b0 P
b0 6
b1 L
b1 .
1K
1,
b0 Q
b0 8
0R
0:
0S
0<
b101 *
b101 >
b101 I
#4000
0B
0#
b0 D
b0 %
b0 A
b0 "
0@
0!
1H
1)
0M
00
b0 O
b0 4
b0 L
b0 .
0K
0,
1S
1<
b100011 *
b100011 >
b100011 I
#6000
1G
1(
0H
0)
1R
1:
0S
0<
b101011 *
b101011 >
b101011 I
#8000
b1 D
b1 %
1C
1$
0G
0(
b1 O
b1 4
1N
12
0R
0:
b10 *
b10 >
b10 I
#10000
b10 E
b10 &
1H
1)
b10 P
b10 6
1S
1<
b11 *
b11 >
b11 I
#12000
xB
x#
bx D
bx %
xC
x$
bx E
bx &
bx A
bx "
x@
x!
bx F
bx '
xG
x(
xH
x)
b0 *
b0 >
b0 I
#14000
0B
0#
b0 D
b0 %
0C
0$
b1 E
b1 &
b10 A
b10 "
1@
1!
b1 F
b1 '
0G
0(
1H
1)
0W
01
b0 Y
b0 5
0X
03
b1 Z
b1 7
b10 V
b10 /
1U
1-
b1 [
b1 9
0\
0;
1]
1=
b100110 +
b100110 ?
b100110 J
b100110 T
#16000
b0 A
b0 "
b0 V
b0 /
b100000 +
b100000 ?
b100000 J
b100000 T
#18000
b1 A
b1 "
b1 V
b1 /
b100010 +
b100010 ?
b100010 J
b100010 T
#20000
b11 A
b11 "
b11 V
b11 /
b101010 +
b101010 ?
b101010 J
b101010 T
#22000
b1 D
b1 %
1C
1$
b0 E
b0 &
b0 A
b0 "
0@
0!
b0 F
b0 '
0H
0)
b1 Y
b1 5
1X
13
b0 Z
b0 7
b0 V
b0 /
0U
0-
b0 [
b0 9
0]
0=
b1000 +
b1000 ?
b1000 J
b1000 T
#24000
