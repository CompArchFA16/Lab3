$date
	Wed Nov 16 21:53:20 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module alucontrol $end
$var wire 2 ! ALUop [1:0] $end
$var wire 6 " instruction [5:0] $end
$var reg 3 # ALUcontrol [2:0] $end
$upscope $end
$scope module cpu $end
$var wire 32 $ ALU_in [31:0] $end
$var wire 3 % ALUop [2:0] $end
$var wire 32 & ALUresult [31:0] $end
$var wire 1 ' ALUsrc $end
$var wire 1 ( ALUzero $end
$var wire 1 ) Branch $end
$var wire 2 * Jump [1:0] $end
$var wire 1 + MemRead $end
$var wire 1 , MemWrite $end
$var wire 2 - MemtoReg [1:0] $end
$var wire 2 . RegDst [1:0] $end
$var wire 1 / RegWrite $end
$var wire 32 0 SEinst [31:0] $end
$var wire 32 1 addALUres [31:0] $end
$var wire 32 2 branch_out [31:0] $end
$var wire 1 3 clk $end
$var wire 32 4 datamem_readData [31:0] $end
$var wire 32 5 inst [31:0] $end
$var wire 32 6 pc4_out [31:0] $end
$var wire 32 7 pc_in [31:0] $end
$var wire 32 8 pc_out [31:0] $end
$var wire 32 9 reg_readData1 [31:0] $end
$var wire 32 : reg_readData2 [31:0] $end
$var wire 32 ; writeData [31:0] $end
$var wire 5 < writeRegister [4:0] $end
$scope module cpuPC $end
$var wire 1 3 clk $end
$var wire 32 = pc_in [31:0] $end
$var reg 32 > pc_out [31:0] $end
$upscope $end
$scope module cpuIM $end
$var wire 32 ? instruction [31:0] $end
$var wire 32 @ read_address [31:0] $end
$upscope $end
$scope module cpuControl $end
$var wire 1 A clk $end
$var wire 6 B instruction [5:0] $end
$var reg 3 C ALUOp [2:0] $end
$var reg 1 D ALUSrc $end
$var reg 1 E Branch $end
$var reg 2 F Jump [1:0] $end
$var reg 1 G MemRead $end
$var reg 1 H MemWrite $end
$var reg 2 I MemtoReg [1:0] $end
$var reg 2 J RegDst [1:0] $end
$var reg 1 K RegWrite $end
$upscope $end
$scope module mux5_inst_reg $end
$var wire 5 L in0 [4:0] $end
$var wire 5 M in1 [4:0] $end
$var wire 5 N in2 [4:0] $end
$var wire 2 O sel [1:0] $end
$var reg 5 P out [4:0] $end
$scope begin MUX $end
$upscope $end
$upscope $end
$scope module cpuRegister $end
$var wire 1 3 clk $end
$var wire 32 Q ra [31:0] $end
$var wire 5 R ra_addr [4:0] $end
$var wire 32 S rb [31:0] $end
$var wire 5 T rb_addr [4:0] $end
$var wire 32 U wd [31:0] $end
$var wire 5 V wd_addr [4:0] $end
$var wire 1 / wrEn $end
$upscope $end
$scope module cpuSE $end
$var wire 16 W seIn [15:0] $end
$var wire 32 X seOut [31:0] $end
$scope begin gen1[16] $end
$upscope $end
$scope begin gen1[17] $end
$upscope $end
$scope begin gen1[18] $end
$upscope $end
$scope begin gen1[19] $end
$upscope $end
$scope begin gen1[20] $end
$upscope $end
$scope begin gen1[21] $end
$upscope $end
$scope begin gen1[22] $end
$upscope $end
$scope begin gen1[23] $end
$upscope $end
$scope begin gen1[24] $end
$upscope $end
$scope begin gen1[25] $end
$upscope $end
$scope begin gen1[26] $end
$upscope $end
$scope begin gen1[27] $end
$upscope $end
$scope begin gen1[28] $end
$upscope $end
$scope begin gen1[29] $end
$upscope $end
$scope begin gen1[30] $end
$upscope $end
$scope begin gen1[31] $end
$upscope $end
$upscope $end
$scope module mux_reg_alu $end
$var wire 32 Y in0 [31:0] $end
$var wire 32 Z in1 [31:0] $end
$var wire 32 [ out [31:0] $end
$var wire 1 ' sel $end
$upscope $end
$scope module cpuALU $end
$var wire 32 \ a [31:0] $end
$var wire 32 ] aluRes [31:0] $end
$var wire 3 ^ alucontrol [2:0] $end
$var wire 32 _ b [31:0] $end
$var wire 1 ( zero $end
$var reg 32 ` aluRes_reg [31:0] $end
$upscope $end
$scope module cpu_dm $end
$var wire 1 + MemRead $end
$var wire 1 , MemWrite $end
$var wire 32 a address [31:0] $end
$var wire 1 3 clk $end
$var wire 32 b readData [31:0] $end
$var wire 32 c writeData [31:0] $end
$var reg 32 d readData_reg [31:0] $end
$upscope $end
$scope module cpu_add_pc $end
$var wire 32 e in [31:0] $end
$var wire 32 f out [31:0] $end
$upscope $end
$scope module mux_datamem $end
$var wire 32 g in0 [31:0] $end
$var wire 32 h in1 [31:0] $end
$var wire 32 i in2 [31:0] $end
$var wire 2 j sel [1:0] $end
$var reg 32 k out [31:0] $end
$scope begin MUX $end
$upscope $end
$upscope $end
$scope module cpu_add_alu $end
$var wire 32 l in0 [31:0] $end
$var wire 32 m in1 [31:0] $end
$var wire 32 n out [31:0] $end
$upscope $end
$scope module mux_branch $end
$var wire 32 o in0 [31:0] $end
$var wire 32 p in1 [31:0] $end
$var wire 32 q out [31:0] $end
$var wire 1 r sel $end
$upscope $end
$scope module mux_jump $end
$var wire 32 s in0 [31:0] $end
$var wire 32 t in1 [31:0] $end
$var wire 32 u in2 [31:0] $end
$var wire 2 v sel [1:0] $end
$var reg 32 w out [31:0] $end
$scope begin MUX $end
$upscope $end
$upscope $end
$upscope $end
$scope module test $end
$var wire 32 x aout [31:0] $end
$var wire 32 y bout [31:0] $end
$var reg 5 z a [4:0] $end
$var reg 5 { b [4:0] $end
$var reg 1 | clk $end
$var reg 32 } wrData [31:0] $end
$var reg 1 ~ wrEn $end
$var reg 5 !" wrReg [4:0] $end
$scope module register $end
$var wire 1 "" clk $end
$var wire 32 #" ra [31:0] $end
$var wire 5 $" ra_addr [4:0] $end
$var wire 32 %" rb [31:0] $end
$var wire 5 &" rb_addr [4:0] $end
$var wire 32 '" wd [31:0] $end
$var wire 5 (" wd_addr [4:0] $end
$var wire 1 )" wrEn $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1)"
b1000 ("
b110010 '"
bx &"
bx %"
b0 $"
b0 #"
0""
b1000 !"
1~
b110010 }
0|
bx {
b0 z
bx y
b0 x
b1 w
b0 v
b0 u
b11101001111111111110000 t
b1 s
0r
b1 q
b1111111111110001 p
b1 o
b1111111111110001 n
b11111111111100 m
b1 l
b11111111111100 k
b0 j
b1 i
bx h
b11111111111100 g
b1 f
b0 e
bx d
bx c
bx b
b11111111111100 a
b11111111111100 `
b11111111111100 _
b100 ^
b11111111111100 ]
b0 \
b11111111111100 [
b11111111111100 Z
bx Y
b11111111111100 X
b11111111111100 W
b111 V
b11111111111100 U
b11101 T
bx S
b0 R
b0 Q
b111 P
b1 O
b11111 N
b111 M
b11101 L
1K
b1 J
b0 I
0H
0G
b0 F
0E
1D
b100 C
b1110 B
zA
b0 @
b111000000111010011111111111100 ?
b0 >
b1 =
b111 <
b11111111111100 ;
bx :
b0 9
b0 8
b1 7
b1 6
b111000000111010011111111111100 5
bx 4
z3
b1 2
b1111111111110001 1
b11111111111100 0
1/
b1 .
b0 -
0,
0+
b0 *
0)
0(
1'
b11111111111100 &
b100 %
b11111111111100 $
b0 #
bz "
bz !
$end
#5000000000000
1|
1""
#10000000000000
b1000 z
b1000 $"
b110010 x
b110010 #"
#60000000000000
